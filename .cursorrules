**pepperpy** is a Python development accelerator that provides a feature-based, vertical architecture library. Each module is self-contained with all necessary components, making it simple to use while maintaining extensibility and customization options.

### Core Architecture Principles
- **Vertical (Feature-Based) Architecture**: Each module is a complete, self-contained feature.
- **Single Responsibility**: Each module handles one specific domain completely.
- **Minimal Configuration**: Ready to use with smart defaults.
- **Extensible Design**: Easy to extend and customize when needed.

### Project Structure (Python 3.12+)
```plaintext
ðŸ“¦pepperpy
 â”ƒ â”— ðŸ“‚pepperpy/
 â”ƒ   â”£ ðŸ“‚core/                # Framework core
 â”ƒ   â”ƒ â”£ ðŸ“œ__init__.py
 â”ƒ   â”ƒ â”£ ðŸ“œapp.py            # Main application
 â”ƒ   â”ƒ â”£ ðŸ“œmodule.py         # Base module system
 â”ƒ   â”ƒ â”— ðŸ“œexceptions.py     # Core exceptions
 â”ƒ   â”ƒ
 â”ƒ   â”£ ðŸ“‚database/           # Database Module (Complete Feature)
 â”ƒ   â”ƒ â”£ ðŸ“œ__init__.py
 â”ƒ   â”ƒ â”£ ðŸ“œmodule.py         # Module implementation
 â”ƒ   â”ƒ â”£ ðŸ“œmodels.py         # Data models
 â”ƒ   â”ƒ â”£ ðŸ“œquery.py          # Query system
 â”ƒ   â”ƒ â”£ ðŸ“œexceptions.py     # Module exceptions
 â”ƒ   â”ƒ â”— ðŸ“‚events/           # Module events
 â”ƒ   â”ƒ   â”£ ðŸ“œ__init__.py
 â”ƒ   â”ƒ   â”— ðŸ“œhandlers.py
 â”ƒ   â”ƒ
 â”ƒ   â”£ ðŸ“‚cache/              # Cache Module (Complete Feature)
 â”ƒ   â”ƒ â”£ ðŸ“œ__init__.py
 â”ƒ   â”ƒ â”£ ðŸ“œmodule.py
 â”ƒ   â”ƒ â”£ ðŸ“œdecorators.py
 â”ƒ   â”ƒ â”— ðŸ“‚backend/
 â”ƒ   â”ƒ   â”£ ðŸ“œ__init__.py
 â”ƒ   â”ƒ   â”— ðŸ“œmemory.py
 â”ƒ   â”ƒ
 â”ƒ   â”— ðŸ“‚<feature_name>/     # New features follow same pattern
 â”ƒ     â”£ ðŸ“œ__init__.py
 â”ƒ     â”£ ðŸ“œmodule.py
 â”ƒ     â”£ ðŸ“œmodels.py
 â”ƒ     â”— ðŸ“œexceptions.py
 â”ƒ
 â”£ ðŸ“‚tests/                  # Tests follow feature structure
 â”ƒ â”£ ðŸ“‚database/
 â”ƒ â”ƒ â”£ ðŸ“œtest_models.py
 â”ƒ â”ƒ â”— ðŸ“œtest_queries.py
 â”ƒ â”£ ðŸ“‚cache/
 â”ƒ â”ƒ â”— ðŸ“œtest_backend.py
 â”ƒ â”— ðŸ“‚<feature_name>/
 â”ƒ   â”— ðŸ“œtest_feature.py
 â”ƒ
 â”£ ðŸ“‚examples/              # Examples by feature
 â”ƒ â”£ ðŸ“‚database_examples/
 â”ƒ â”— ðŸ“‚cache_examples/
 â”ƒ
 â”£ ðŸ“œpyproject.toml
 â”£ ðŸ“œREADME.md
 â”— ðŸ“œLICENSE
```

### Module Structure Guidelines
Each feature module MUST follow this structure:
```python
# module.py - Main module implementation
class FeatureModule(BaseModule):
    __module_name__ = 'feature_name'
    
    async def setup(self) -> None:
        """Module initialization."""
        pass
        
    async def cleanup(self) -> None:
        """Resource cleanup."""
        pass

# models.py - Domain models
class FeatureModel:
    """Feature-specific models."""
    pass

# exceptions.py - Feature exceptions
class FeatureError(Exception):
    """Feature-specific exceptions."""
    pass
```

### Development Standards
- **Language**: English for all code, comments, and documentation.
- **Python Version**: 3.12+
- **Type Hints**: Mandatory for all public interfaces; no use of `typing.Any` where prohibited by Ruff.
- **Documentation**: Clear docstrings for all public components, following Google style.
- **Testing**: Feature-based test organization.

### Code Style and Quality
- **Formatting**: `black` for consistent formatting.
- **Linting**: `ruff` for code quality, addressing warnings such as:
  - Missing return type annotations (`ANN204`).
  - Missing type annotations for function arguments (`ANN001`).
  - Implicit `Optional` prohibited (`RUF013`).
  - Unused imports (`F401`).
  - Explicit f-string conversions (`RUF010`).
  - Dangling tasks in asyncio (`RUF006`).
- **Type Checking**: `mypy` in strict mode.
- **Import Order**: `isort` for consistent imports.

### Feature Module Template
New features should follow this template:

```python
from pepperpy.core import BaseModule
from typing import Optional

class NewFeatureModule(BaseModule):
    """
    Feature description
    
    Attributes:
        name (str): Module name
        config (dict): Module configuration
    
    Examples:
        >>> module = NewFeatureModule()
        >>> await module.setup()
    """
    __module_name__ = 'new_feature'
    
    async def setup(self) -> None:
        """Initialize the module."""
        pass
    
    async def cleanup(self) -> None:
        """Cleanup resources."""
        pass
    
    def feature_method(self) -> Optional[str]:
        """Feature-specific functionality."""
        pass
```

### Documentation Requirements
Each feature module must include:
- **README.md**: Usage examples.
- **API documentation**: Type hints, parameters, and return types.
- **Configuration options**.
- **Example implementations**.

### Quality Checks
- **All tests passing**: Minimum of 90% coverage.
- **Type check**: No errors in `mypy` strict mode.
- **Code formatting**: Verified with `black`.
- **Documentation**: Updated and in Google docstring style.
- **Examples**: Verified to be working.

### PepperPy Development Guidelines

#### Core Principles

1. **Module Independence**
   - Self-contained functionality.
   - Explicit dependencies.
   - Clear boundaries.

2. **Composition First**
   - Builder pattern for configuration.
   - Event-based communication.
   - Lifecycle hooks.

3. **Developer Experience**
   - Type safety.
   - Clear error messages.
   - Consistent patterns.

#### Module Structure

```plaintext
ðŸ“‚module_name/
 â”£ ðŸ“œ__init__.py        # Public API
 â”£ ðŸ“œmodule.py          # Module implementation
 â”£ ðŸ“œexceptions.py      # Module exceptions
 â”£ ðŸ“œevents.py          # Module events
 â”— ðŸ“‚components/        # Internal components
   â”£ ðŸ“œ__init__.py
   â”— ðŸ“œ{component}.py
```

#### Implementation Guidelines

1. **Module Definition**
   ```python
   from typing import Optional

   class MyModule(BaseModule):
       """
       Clear module description.
       
       Attributes:
           config (ModuleConfig): Module configuration.
       
       Examples:
           >>> module = MyModule.create()\\
           ...     .configure(setting="value")\\
           ...     .build()
       """
       __module_name__ = "my_module"
       __dependencies__ = ["other_module"]
       
       async def initialize(self) -> None:
           await super().initialize()
           # Setup resources
           
       async def shutdown(self) -> None:
           await super().shutdown()
           # Cleanup resources
   ```

2. **Event Handling**
   ```python
   async def post_initialize(self) -> None:
       """Subscribe to events after initialization."""
       self._event_bus.subscribe("other.event", self._handle_event)
       
   def _handle_event(self, event: Event) -> None:
       """Handle specific event."""
       pass
   ```

#### Documentation Standards

1. **Module Documentation**
   - Purpose and features.
   - Configuration options.
   - Event descriptions.
   - Error scenarios.

2. **API Documentation**
   - Type hints.
   - Parameters.
   - Return values.
   - Exceptions.

3. **Examples**
   - Basic usage.
   - Common patterns.
   - Error handling.

#### Quality Checks

1. **Code Quality**
   - Black formatting.
   - Ruff linting for common issues, including:
     - `typing.Any` restrictions.
     - Implicit `Optional`.
     - Explicit f-string type conversions.
     - Missing return type annotations.
   - isort imports.
   - mypy strict mode.

2. **Runtime Checks**
   - Type validation.
   - Config validation.
   - Resource cleanup.

3. **Documentation**
   - Google-style docstrings.
   - Up-to-date examples.
   - Changelog maintained.
