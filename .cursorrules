# PepperPy Development Rules

## Architecture Principles
- Modular, self-contained architecture
- Each module is autonomous and responsible for its own structure
- Core module holds only essential framework and shared utilities
- Configuration managed through metadata
- Async-first development
- Type-safe implementation

## Module Structure

The project structure is minimalist but categorized, organizing modules within directories representing functional categories. This approach keeps related modules grouped logically without rigid naming requirements, allowing for expansion while maintaining clarity.

```plaintext
pepperpy/
├── <category>/
│   ├── <module_name>/
│   │   ├── __init__.py       # Public interface and entry point
│   │   └── ...               # Additional files as needed, per module’s design
├── core/
│   ├── __init__.py           # Core utilities and shared functions
│   ├── config.py             # Global configuration and metadata
│   ├── registry.py           # Dependency and module registration management
│   └── utils.py              # Common utilities
├── pyproject.toml            # Project configuration
└── README.md                 # Project overview
```
## Dependency Management
- Only use actively maintained libraries with recent updates (last 6 months)
- Avoid deprecated or unmaintained libraries
- Always use the latest stable versions of dependencies
- Regularly update dependencies to their newest versions
- Prefer modern, feature-rich libraries with good community support

## Module Structure and Guidelines

### Modular Layout and Granularity
- **Public Interface**: Each module should have an `__init__.py` file that exposes its public interface and connects core functionality, ensuring a consistent entry point.
- **Granular Design**: Each module should be as small and focused as possible, ideally containing a single, well-defined functionality. For large feature sets or additional responsibilities, split functionality across multiple, smaller modules within the appropriate category.
- **Flexible File and Folder Structure**: File naming and internal structure are determined by each module’s needs, without mandatory files like `config.py` or `exceptions.py`.
  
### Core
- **Core Module**: The `core/` directory contains global configurations, dependency registration, and shared utilities, which other modules can reuse.
- **Registry**: `core/registry.py` manages dependencies and module registration, enabling centralized initialization.

## Development and Code Standards

1. **Configuration**: Configure each module through metadata, either in `__init__.py` or other internal files as needed.
2. **Public Interface**: Expose each module’s public interface in `__init__.py`.
3. **Modular Independence**: Each module must be fully independent, allowing for internal evolution without impacting other modules.
4. **Async Development**: Use async/await for all asynchronous functions.
5. **Error Handling**: Define module-specific exceptions, preferably within the module, and handle errors in a clear, predictable manner.
6. **Type Safety**: All modules should use full and consistent type annotations, with `mypy` and `ruff` to ensure code consistency.
7. **Comment Guidelines**: Avoid generating comments that describe the implementation, such as `# Implementation of RichApp`, or any other unnecessary comments. Always provide complete and functional code without generic comments.
8. **Documentation**: All documentation and comments must be generated in English.
