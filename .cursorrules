**pepperpy** is a Python development accelerator that provides a feature-based, vertical architecture library. Each module is self-contained with all necessary components, making it simple to use while maintaining extensibility and customization options.

### Core Architecture Principles
- **Vertical (Feature-Based) Architecture**: Each module is a complete, self-contained feature
- **Single Responsibility**: Each module handles one specific domain completely
- **Minimal Configuration**: Ready to use with smart defaults
- **Extensible Design**: Easy to extend and customize when needed

### Project Structure (Python 3.13)
```plaintext
ðŸ“¦pepperpy
 â”£ ðŸ“‚src/
 â”ƒ â”— ðŸ“‚pepperpy/
 â”ƒ   â”£ ðŸ“‚core/                # Framework core
 â”ƒ   â”ƒ â”£ ðŸ“œ__init__.py
 â”ƒ   â”ƒ â”£ ðŸ“œapp.py            # Main application
 â”ƒ   â”ƒ â”£ ðŸ“œmodule.py         # Base module system
 â”ƒ   â”ƒ â”— ðŸ“œexceptions.py     # Core exceptions
 â”ƒ   â”ƒ
 â”ƒ   â”£ ðŸ“‚database/           # Database Module (Complete Feature)
 â”ƒ   â”ƒ â”£ ðŸ“œ__init__.py
 â”ƒ   â”ƒ â”£ ðŸ“œmodule.py         # Module implementation
 â”ƒ   â”ƒ â”£ ðŸ“œmodels.py         # Data models
 â”ƒ   â”ƒ â”£ ðŸ“œquery.py          # Query system
 â”ƒ   â”ƒ â”£ ðŸ“œexceptions.py     # Module exceptions
 â”ƒ   â”ƒ â”— ðŸ“‚events/           # Module events
 â”ƒ   â”ƒ   â”£ ðŸ“œ__init__.py
 â”ƒ   â”ƒ   â”— ðŸ“œhandlers.py
 â”ƒ   â”ƒ
 â”ƒ   â”£ ðŸ“‚cache/              # Cache Module (Complete Feature)
 â”ƒ   â”ƒ â”£ ðŸ“œ__init__.py
 â”ƒ   â”ƒ â”£ ðŸ“œmodule.py
 â”ƒ   â”ƒ â”£ ðŸ“œdecorators.py
 â”ƒ   â”ƒ â”— ðŸ“‚backend/
 â”ƒ   â”ƒ   â”£ ðŸ“œ__init__.py
 â”ƒ   â”ƒ   â”— ðŸ“œmemory.py
 â”ƒ   â”ƒ
 â”ƒ   â”— ðŸ“‚<feature_name>/     # New features follow same pattern
 â”ƒ     â”£ ðŸ“œ__init__.py
 â”ƒ     â”£ ðŸ“œmodule.py
 â”ƒ     â”£ ðŸ“œmodels.py
 â”ƒ     â”— ðŸ“œexceptions.py
 â”ƒ
 â”£ ðŸ“‚tests/                  # Tests follow feature structure
 â”ƒ â”£ ðŸ“‚database/
 â”ƒ â”ƒ â”£ ðŸ“œtest_models.py
 â”ƒ â”ƒ â”— ðŸ“œtest_queries.py
 â”ƒ â”£ ðŸ“‚cache/
 â”ƒ â”ƒ â”— ðŸ“œtest_backend.py
 â”ƒ â”— ðŸ“‚<feature_name>/
 â”ƒ   â”— ðŸ“œtest_feature.py
 â”ƒ
 â”£ ðŸ“‚examples/              # Examples by feature
 â”ƒ â”£ ðŸ“‚database_examples/
 â”ƒ â”— ðŸ“‚cache_examples/
 â”ƒ
 â”£ ðŸ“œpyproject.toml
 â”£ ðŸ“œREADME.md
 â”— ðŸ“œLICENSE
```

### Module Structure Guidelines
Each feature module MUST follow this structure:
```python
# module.py - Main module implementation
class FeatureModule(BaseModule):
    __module_name__ = 'feature_name'
    
    async def setup(self):
        """Module initialization"""
        pass
        
    async def cleanup(self):
        """Resource cleanup"""
        pass

# models.py - Domain models
class FeatureModel:
    """Feature specific models"""
    pass

# exceptions.py - Feature exceptions
class FeatureError(Exception):
    """Feature specific exceptions"""
    pass
```

### Development Standards
- **Language**: English for all code, comments, and documentation
- **Python Version**: 3.13+
- **Type Hints**: Mandatory for all public interfaces
- **Documentation**: Clear docstrings for all public components
- **Testing**: Feature-based test organization, 90%+ coverage

### Code Style and Quality
- **Formatting**: `black` for consistent formatting
- **Linting**: `ruff` for code quality
- **Type Checking**: `mypy` with strict mode
- **Import Order**: `isort` for consistent imports
- **Documentation**: Google style docstrings

### Feature Module Template
New features should follow this template:
```python
from pepperpy.core import BaseModule

class NewFeatureModule(BaseModule):
    """
    Feature description
    
    Attributes:
        name (str): Module name
        config (dict): Module configuration
    
    Examples:
        >>> module = NewFeatureModule()
        >>> await module.setup()
    """
    __module_name__ = 'new_feature'
    
    async def setup(self):
        """Initialize the module"""
        pass
    
    async def cleanup(self):
        """Cleanup resources"""
        pass
    
    def feature_method(self):
        """Feature specific functionality"""
        pass
```

### Documentation Requirements
Each feature module must include:
- README.md with usage examples
- API documentation
- Configuration options
- Example implementations

### Quality Checks
- All tests passing
- No type check errors
- Code formatting verified
- Documentation updated
- Examples tested and working

### PepperPy Development Guidelines

## Core Principles

1. Module Independence
   - Self-contained functionality
   - Explicit dependencies
   - Clear boundaries

2. Composition First
   - Builder pattern for configuration
   - Event-based communication
   - Lifecycle hooks

3. Developer Experience
   - Type safety
   - Clear error messages
   - Consistent patterns

## Module Structure

```plaintext
ðŸ“‚module_name/
 â”£ ðŸ“œ__init__.py        # Public API
 â”£ ðŸ“œmodule.py          # Module implementation
 â”£ ðŸ“œexceptions.py      # Module exceptions
 â”£ ðŸ“œevents.py          # Module events
 â”— ðŸ“‚components/        # Internal components
   â”£ ðŸ“œ__init__.py
   â”— ðŸ“œ{component}.py
```

## Implementation Guidelines

1. Module Definition
```python
class MyModule(BaseModule):
    """
    Clear module description
    
    Attributes:
        config (ModuleConfig): Module configuration
    
    Examples:
        >>> module = MyModule.create()\\
        ...     .configure(setting="value")\\
        ...     .build()
    """
    __module_name__ = "my_module"
    __dependencies__ = ["other_module"]
    
    async def initialize(self) -> None:
        await super().initialize()
        # Setup resources
        
    async def shutdown(self) -> None:
        await super().shutdown()
        # Cleanup resources
```

2. Event Handling
```python
async def post_initialize(self) -> None:
    """Subscribe to events after initialization"""
    self._event_bus.subscribe("other.event", self._handle_event)
    
def _handle_event(self, event: Event) -> None:
    """Handle specific event"""
    pass
```

## Testing Requirements

1. Unit Tests
   - Test each component in isolation
   - Mock dependencies
   - Test error paths

2. Integration Tests
   - Test module lifecycle
   - Test event handling
   - Test with dependencies

3. Coverage Requirements
   - 100% for public API
   - 90%+ overall coverage
   - Error handling tested

## Documentation Standards

1. Module Documentation
   - Purpose and features
   - Configuration options
   - Event descriptions
   - Error scenarios

2. API Documentation
   - Type hints
   - Parameters
   - Return values
   - Exceptions

3. Examples
   - Basic usage
   - Common patterns
   - Error handling

## Quality Checks

1. Code Quality
   - Black formatting
   - Ruff linting
   - isort imports
   - mypy strict mode

2. Runtime Checks
   - Type validation
   - Config validation
   - Resource cleanup

3. Documentation
   - Google style docstrings
   - Up-to-date examples
   - Changelog maintained